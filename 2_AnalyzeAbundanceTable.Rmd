---
title: "Simulations"
author: "Nicolas Rode"
date: "`r format(Sys.Date(), '%d-%B-%Y')`"
output: 
  html_document:
    theme: "journal"
    toc: true
    toc_depth: 3
    number_sections: true
    toc_float:
      collapsed: false
      smooth_scroll: false
editor_options: 
  chunk_output_type: console
---


```{r setup, include =FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
devtools::load_all()
```


# Simulating count data in R
```{r }

## Install JAGS standalone: https://sourceforge.net/projects/mcmc-jags/files/JAGS/4.x/
library(rjags)

Nsamples=1000
lambda=50
## Fixed number of individuals per sample
data <- sample_Binomial(Nsamples=Nsamples, prob=0.5, mean_nindiviuals_per_habitat=rep(lambda, Nsamples))
```
# Analyze data
```{r }
modelBinomial <-
"model{ 
    # likelihood
    for (i in 1:N){
            lambda[i] <- d
            Ntot[i] ~ dpois(lambda[i])
            OTU1[i] ~ dbin(p[i], Ntot[i])
            logit(p[i]) <- alpha
    }
    # priors
    d ~ dunif(1, 100)
    alpha ~ dunif(-10,10)

}"

data$Ntot <- data$OTU1+data$OTU2

data4jags <- list(N = length(data$OTU1), OTU1 = data$OTU1, Ntot = data$Ntot)
   
# Definition des valeurs initiales des noeuds entrants pour chaque chaîne
ini1 <- list(d = 1)
ini2 <- list(d = 10)
ini3 <- list(d = 2)
ini <- list(ini1, ini2, ini3)


require(rjags)
model <- jags.model(file = textConnection(modelBinomial), data = data4jags,
                    inits = ini, n.chains = 3)

update(model, 5000)

mcmc <- coda.samples(model, c("d", "alpha"), n.iter = 5000)

summary(mcmc)
# Tracé basique des chaînes non réalisé ici
# plot(mcmc, trace = TRUE, density = FALSE)
# Tracé des chaînes avec xyplot{lattice}
require(lattice)
xyplot(mcmc)

gelman.diag(mcmc)

gelman.plot(mcmc)

geweke.diag(mcmc)


cumuplot(mcmc[[1]]) # ici appliqué uniquement à la première chaîne pour limiter l'encombrement

autocorr.plot(mcmc[[1]]) # ici appliqué uniquement à la première chaîne pour limiter l'encombrement

# estimation de la taille effective du fait de l'autocorrélation pour l'ensemble
# des 3 chaînes 3*5000 = 15000
effectiveSize(mcmc)


# même calcul par chaîne
lapply(mcmc, effectiveSize)


# diagnostic de Raftery
raftery.diag(mcmc)
```

